<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no">
	<title>Neon Tetris - Free Browser Puzzle Game (No Download) | SlackingGames</title>    <style>
        /* 1. 基础与防误触 */
        body {
            background: #050505;
            color: #fff;
            font-family: 'Courier New', monospace;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            margin: 0;
            overflow: hidden;
            touch-action: none; /* 禁止滚动 */
            -webkit-touch-callout: none; /* 禁止iOS长按 */
            -webkit-user-select: none;
            user-select: none;
        }

        /* 2. 游戏容器与震动特效 */
        #game-box {
            position: relative;
            border: 2px solid #333;
            box-shadow: 0 0 40px rgba(0, 255, 255, 0.1);
            background: rgba(0,0,0,0.9);
        }
        
        /* 震动动画 class */
        .shake { animation: shake 0.2s cubic-bezier(.36,.07,.19,.97) both; }
        @keyframes shake {
            10%, 90% { transform: translate3d(-2px, 0, 0); }
            20%, 80% { transform: translate3d(4px, 0, 0); }
            30%, 50%, 70% { transform: translate3d(-6px, 0, 0); }
            40%, 60% { transform: translate3d(6px, 0, 0); }
        }

        canvas { display: block; }

        /* 3. UI 面板 */
        #ui {
            width: 100%;
            display: flex;
            justify-content: space-between;
            padding: 10px 0;
            color: #0cf;
            font-size: 18px;
            font-weight: bold;
            text-shadow: 0 0 10px #0cf;
            position: absolute;
            top: -40px; left: 0;
        }

        /* 4. 手机控制按钮 */
        #ctrl {
            display: none; /* 电脑隐藏 */
            margin-top: 20px;
            gap: 15px;
            grid-template-columns: repeat(3, 60px);
            grid-template-rows: 60px 60px;
        }

        @media(max-width: 800px) {
            #ctrl { display: grid; }
            canvas { width: 65vw; } /* 手机上稍微缩小一点给按钮留位置 */
        }

        .btn {
            background: rgba(0, 204, 255, 0.1);
            border: 1px solid #0cf;
            color: #0cf;
            border-radius: 50%;
            font-size: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 0 10px rgba(0, 204, 255, 0.2);
            cursor: pointer;
        }
        .btn:active { background: #0cf; color: #000; box-shadow: 0 0 20px #0cf; }

        #b-l { grid-row: 2; grid-column: 1; }
        #b-r { grid-row: 2; grid-column: 3; }
        #b-d { grid-row: 2; grid-column: 2; }
        #b-rot { grid-row: 1; grid-column: 2; background: rgba(255, 204, 0, 0.1); border-color: #fc0; color: #fc0; }

    </style>
</head>
<body>

    <div style="position:relative">
        <div id="ui">
            <span>SCORE: <span id="s">0</span></span>
        </div>
        <div id="game-box">
            <canvas id="t" width="240" height="400"></canvas>
        </div>
    </div>

    <div id="ctrl">
        <div class="btn" id="b-rot">↻</div>
        <div class="btn" id="b-l">←</div>
        <div class="btn" id="b-d">↓</div>
        <div class="btn" id="b-r">→</div>
    </div>

    <script>
        const cv=document.getElementById('t'), ctx=cv.getContext('2d'), box=document.getElementById('game-box');
        ctx.scale(20, 20);

        // 霓虹配色
        const C=[null,'#FF0D72','#0DC2FF','#0DFF72','#F538FF','#FF8E0D','#FFE138','#3877FF'];
        const P='ILJOTSZ';

        // 粒子系统
        let particles = [];
        function createParticles(y) {
            for(let i=0; i<10; i++) {
                particles.push({
                    x: Math.random() * 12, // 这里的坐标是基于 grid (0-12)
                    y: y, 
                    vx: (Math.random() - 0.5) * 0.5,
                    vy: (Math.random() - 0.5) * 0.5,
                    life: 1.0,
                    color: C[Math.floor(Math.random() * 7) + 1]
                });
            }
        }

        // 核心逻辑
        function cM(w,h){const m=[];while(h--)m.push(new Array(w).fill(0));return m}
        function cP(t){
            if(t=='I')return[[0,1,0,0],[0,1,0,0],[0,1,0,0],[0,1,0,0]];
            if(t=='L')return[[0,2,0],[0,2,0],[0,2,2]];
            if(t=='J')return[[0,3,0],[0,3,0],[3,3,0]];
            if(t=='O')return[[4,4],[4,4]];
            if(t=='Z')return[[5,5,0],[0,5,5],[0,0,0]];
            if(t=='S')return[[0,6,6],[6,6,0],[0,0,0]];
            if(t=='T')return[[0,7,0],[7,7,7],[0,0,0]];
        }

        let ar=cM(12,20), pl={p:{x:0,y:0},m:null,s:0}, dr=0, last=0;

        function collide(a,p){
            const[m,o]=[p.m,p.p];
            for(let y=0;y<m.length;++y)
                for(let x=0;x<m[y].length;++x)
                    if(m[y][x]!==0&&(a[y+o.y]&&a[y+o.y][x+o.x])!==0)return 1;
            return 0;
        }

        function draw(){
            // 1. 清屏
            ctx.fillStyle='#000';
            ctx.fillRect(0,0,cv.width,cv.height);
            
            // 2. 画矩阵 (带光晕)
            drawMatrix(ar, {x:0,y:0});
            drawMatrix(pl.m, pl.p);

            // 3. 画粒子
            particles.forEach((p, i) => {
                if(p.life > 0) {
                    ctx.globalAlpha = p.life;
                    ctx.fillStyle = p.color;
                    ctx.fillRect(p.x, p.y, 0.4, 0.4); // 绘制小碎片
                    p.x += p.vx;
                    p.y += p.vy;
                    p.life -= 0.05;
                } else {
                    particles.splice(i, 1);
                }
            });
            ctx.globalAlpha = 1.0;
        }

        function drawMatrix(m,o){
            m.forEach((r,y)=>{
                r.forEach((v,x)=>{
                    if(v!==0){
                        ctx.fillStyle=C[v];
                        // 霓虹光晕
                        ctx.shadowBlur=15; ctx.shadowColor=C[v];
                        ctx.fillRect(x+o.x, y+o.y, 1, 1);
                        // 高光
                        ctx.fillStyle='rgba(255,255,255,0.3)';
                        ctx.fillRect(x+o.x+0.1, y+o.y+0.1, 0.3, 0.3);
                        ctx.shadowBlur=0; // 重置以免影响性能
                    }
                })
            });
        }

        function merge(a,p){
            p.m.forEach((r,y)=>{
                r.forEach((v,x)=>{
                    if(v!==0)a[y+p.p.y][x+p.p.x]=v;
                });
            });
        }

        function rotate(m,d){
            for(let y=0;y<m.length;++y)
                for(let x=0;x<y;++x)[m[x][y],m[y][x]]=[m[y][x],m[x][y]];
            if(d>0)m.forEach(r=>r.reverse());
            else m.reverse();
        }

        function playerReset(){
            pl.m=cP(P[P.length*Math.random()|0]);
            pl.p.y=0;
            pl.p.x=(ar[0].length/2|0)-(pl.m[0].length/2|0);
            if(collide(ar,pl)){
                ar.forEach(r=>r.fill(0));
                pl.s=0;
                updateScore();
            }
        }

        function shakeScreen() {
            box.classList.remove('shake');
            void box.offsetWidth; // 触发重绘
            box.classList.add('shake');
        }

        function sweep(){
            let rc=1;
            outer:for(let y=ar.length-1;y>0;--y){
                for(let x=0;x<ar[y].length;++x)
                    if(ar[y][x]===0)continue outer;
                
                const r=ar.splice(y,1)[0].fill(0);
                ar.unshift(r);
                ++y;
                
                // 消除特效
                pl.s+=rc*10;
                rc*=2;
                shakeScreen(); // 震动
                createParticles(y); // 爆炸
            }
            updateScore();
        }

        function playerDrop(){
            pl.p.y++;
            if(collide(ar,pl)){
                pl.p.y--;
                merge(ar,pl);
                shakeScreen(); // 落地也震动一下，增加打击感
                playerReset();
                sweep();
            }
            dr=0;
        }

        function playerMove(d){
            pl.p.x+=d;
            if(collide(ar,pl))pl.p.x-=d;
        }

        function playerRotate(d){
            const p=pl.p.x; let o=1;
            rotate(pl.m,d);
            while(collide(ar,pl)){
                pl.p.x+=o;
                o=-(o+(o>0?1:-1));
                if(o>pl.m[0].length){
                    rotate(pl.m,-d);pl.p.x=p;return;
                }
            }
        }

        function updateScore(){ document.getElementById('s').innerText=pl.s; }

        function update(t=0){
            const dt=t-last; last=t;
            dr+=dt;
            if(dr>1000)playerDrop();
            draw();
            requestAnimationFrame(update);
        }

        // 键盘控制
        document.addEventListener('keydown',e=>{
            if(e.keyCode===37)playerMove(-1);
            else if(e.keyCode===39)playerMove(1);
            else if(e.keyCode===40)playerDrop();
            else if(e.keyCode===38)playerRotate(1);
        });

        // 触摸按钮控制
        function bindBtn(id, fn) {
            const btn = document.getElementById(id);
            btn.addEventListener('touchstart', (e) => { 
                e.preventDefault(); 
                fn();
            }, {passive: false});
            // 兼容电脑鼠标点击
            btn.addEventListener('mousedown', (e) => { e.preventDefault(); fn(); });
        }

        bindBtn('b-l', () => playerMove(-1));
        bindBtn('b-r', () => playerMove(1));
        bindBtn('b-d', () => playerDrop());
        bindBtn('b-rot', () => playerRotate(1));

        playerReset();
        update();
    </script>
</body>
</html>